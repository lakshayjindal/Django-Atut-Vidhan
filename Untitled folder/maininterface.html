{% extends "../base.html" %}
{% load static %}

{% block title %}Chats{% endblock %}

{% block extra_head %}
<link rel="stylesheet" href="{% static 'chat/chat.css' %}">
<style>
  :root{
    --bg:#0f0f14; /* deep ink */
    --panel:#151623; /* card */
    --accent:#FFD166; /* warm gold */
    --accent-2:#EF476F; /* ruby */
    --accent-3:#7EE787; /* jade */
    --muted:#9aa0aa;
    --ring: 0 0 0 2px rgba(239,71,111,.35), 0 10px 25px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Poppins", "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
    background: radial-gradient(1200px 800px at 90% -10%, rgba(239,71,111,.15), transparent 60%),
                radial-gradient(800px 800px at -20% 110%, rgba(255,209,102,.15), transparent 60%),
                var(--bg);
    color:#e8e9ee;
  }

  .container{
    --sidebar-w: 320px;
    height: calc(100vh - 70px);
    display:flex;
    overflow:hidden;
    border-top:1px solid rgba(255,255,255,.06);
    border-bottom:1px solid rgba(255,255,255,.06);
    backdrop-filter: blur(6px);
  }

  /* Sidebar */
  .sidebar{
    width:var(--sidebar-w);
    background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    border-right:1px solid rgba(255,255,255,.08);
    padding:18px 14px;
    overflow-y:auto;
  }
  .sidebar h2{margin:8px 8px 16px; font-size:14px; letter-spacing:.08em; font-weight:700; color:var(--accent)}
  .chat-user{
    display:flex;align-items:center;gap:12px;
    padding:10px 10px; margin:4px 0; border-radius:14px; text-decoration:none; color:#eaeaf0;
    background:transparent; border:1px solid transparent;
    transition: all .18s ease;
  }
  .chat-user:hover{background:rgba(255,255,255,.04); border-color:rgba(255,255,255,.08); transform: translateY(-1px)}
  .chat-user.selected-chat{background:rgba(239,71,111,.08); border-color:rgba(239,71,111,.25)}
  .chat-user img{width:42px;height:42px;border-radius:12px; border:2px solid rgba(255,255,255,.12); object-fit:cover}
  .chat-user .meta{display:flex; flex-direction:column}
  .chat-user .meta .name{font-weight:600;}
  .chat-user .meta .last{font-size:12px; color:var(--muted)}

  /* Chat panel */
  .chat-section{flex:1; display:flex; flex-direction:column; min-width:0; position:relative;}
  .chat-bg{position:absolute; inset:0; background-image:url('{% static "user/img/mandala.png" %}'); background-position:center; background-repeat:no-repeat; opacity:.035; pointer-events:none}

  /* Header */
  .chat-header{
    z-index:3; position:sticky; top:0; display:flex; align-items:center; gap:12px;
    padding:14px 18px; background-color: rgba(10,11,18,.75); backdrop-filter: blur(10px);
    border-bottom:1px solid rgba(255,255,255,.08);
  }
  .chat-header img{width:46px;height:46px;border-radius:14px;border:2px solid rgba(239,71,111,.55); object-fit:cover}
  .chat-header .titles{display:flex; flex-direction:column}
  .chat-header .titles h3{margin:0; font-size:16px; color:#fff}
  .chat-header .presence{font-size:12px; color:var(--muted)}
  .status-dot{display:inline-block; width:8px; height:8px; border-radius:50%; margin-right:6px; background: #c84848}
  .status-dot.online{background: #3fb950}

  /* Messages */
  .chat-messages{
    position:relative; flex:1; overflow-y:auto; padding:18px 18px 0 18px; display:flex; flex-direction:column; gap:10px;
  }
  .scroll-shadow-top, .scroll-shadow-btm{position:sticky;height:20px;pointer-events:none;z-index:2}
  .scroll-shadow-top{top:0;background: linear-gradient(180deg, rgba(0,0,0,.25), transparent)}
  .scroll-shadow-btm{bottom:0;background: linear-gradient(0deg, rgba(0,0,0,.25), transparent)}

  .day-divider{align-self:center; font-size:12px; color:var(--muted); padding:6px 10px; border:1px solid rgba(255,255,255,.08); border-radius:999px; background: rgba(255,255,255,.03)}

  .message{max-width:68%; padding:10px 14px; border-radius:16px; font-size:14px; word-wrap:break-word; box-shadow: var(--ring); transform-origin: bottom; animation: pop .18s ease}
  @keyframes pop { from{opacity:0; transform: translateY(4px) scale(.98)} to{opacity:1; transform: translateY(0) scale(1)} }
  .sent{align-self:flex-end; background: linear-gradient(135deg, rgba(239,71,111,.9), rgba(239,71,111,.7)); color:#fff; border:1px solid rgba(239,71,111,.25)}
  .received{align-self:flex-start; background: linear-gradient(135deg, rgba(255,209,102,.9), rgba(255,209,102,.7)); color:#2b2113; border:1px solid rgba(255,209,102,.4)}
  .message .meta{margin-top:6px; font-size:11px; opacity:.8}
  .message img{max-width:260px; border-radius:12px; margin-top:6px; border:1px solid rgba(255,255,255,.25)}
  .file-pill{display:inline-flex; align-items:center; gap:8px; background: rgba(255,255,255,.15); padding:6px 10px; border-radius:999px; margin-top:6px}

  .typing{align-self:flex-start; display:flex; align-items:center; gap:8px; padding:8px 12px; border-radius:14px; background: rgba(255,255,255,.06); border:1px dashed rgba(255,255,255,.15); color:var(--muted)}
  .dots{display:inline-block; width:32px; height:10px; background:
      radial-gradient(circle closest-side, currentColor 90%, transparent) 0% 50%/8px 8px,
      radial-gradient(circle closest-side, currentColor 90%, transparent) 50% 50%/8px 8px,
      radial-gradient(circle closest-side, currentColor 90%, transparent) 100% 50%/8px 8px;
      background-repeat:no-repeat; animation: bounce 1.2s infinite ease-in-out}
  @keyframes bounce{33%{transform: translateY(-1px)} 66%{transform: translateY(1px)}}

  /* Composer */
  .composer-wrap{padding:14px; background: rgba(10,11,18,.75); backdrop-filter: blur(10px); border-top:1px solid rgba(255,255,255,.08)}
  .composer{
    display:flex; gap:10px; align-items:center; background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:8px 10px;
  }
  .composer input[type="text"]{flex:1; background:transparent; border:none; outline:none; color:#fff; padding:10px 8px; font-size:14px}
  .composer .btn{border:none; cursor:pointer; border-radius:12px; padding:10px; transition: transform .12s ease, background .12s ease}
  .btn.attach{background: rgba(255,209,102,.15)}
  .btn.send{background: linear-gradient(135deg, #ef476f, #c23a59); color:#fff}
  .btn:hover{transform: translateY(-1px)}

  .empty{display:flex; align-items:center; justify-content:center; color:var(--muted); height:100%}

  @media (max-width: 900px){ .sidebar{display:none} .container{height: calc(100vh - 0px)} }
</style>
{% endblock %}

{% block content %}
<div class="container">
  <!-- Sidebar -->
  <aside class="sidebar">
    <h2>Chats</h2>
    {% for chat_user in chat_users %}
      <a href="{% url 'chat' chat_with=chat_user.id %}" class="chat-user {% if chat_user.id == selected_user_id %}selected-chat{% endif %}">
        {% if chat_user.profile.image %}
          <img src="{{ chat_user.profile.image.url }}" alt="Profile picture">
        {% else %}
          {% if chat_user.profile.gender == "Male" %}
            <img src="{{ DEFAULT_MALE_FALLBACK_URL }}" alt="Default male profile picture">
          {% else %}
            <img src="{{ DEFAULT_FEMALE_FALLBACK_URL }}" alt="Default female profile picture">
          {% endif %}
        {% endif %}
        <span class="meta">
          <span class="name">{{ chat_user.get_full_name }}</span>
          <span class="last">{{ chat_user.last_message_preview|default:"" }}</span>
        </span>
      </a>
    {% endfor %}
  </aside>

  <!-- Chat Section -->
  <section class="chat-section" id="chatContainer">
    <div class="chat-bg"></div>

    {% if selected_user %}
    <!-- Header -->
    <div class="chat-header">
      {% if selected_user.image.url %}
        <img src="{{ selected_user.image.url }}" alt="User Picture">
      {% else %}
        <img src="{% static 'user/img/default.webp' %}" alt="Default profile picture">
      {% endif %}
      <div class="titles">
        <h3>{{ selected_user.get_full_name }}</h3>
        <span class="presence"><span id="wsDot" class="status-dot"></span><span id="wsStatus">Connectingâ€¦</span></span>
      </div>
      <div style="margin-left:auto; font-size:12px; color:var(--muted)" id="typingHint"></div>
    </div>

    <!-- Messages -->
    <div class="chat-messages" id="chatMessages" data-last-id="0">
      <div class="scroll-shadow-top"></div>
      <!-- Older loader sentinel -->
      <div id="olderSentinel" style="align-self:center; font-size:12px; color:var(--muted); padding:6px 10px; display:none">Loading earlier messagesâ€¦</div>
      {% for msg in messages %}
        {% include "../partials/_message.html" with msg=msg %}
      {% endfor %}
      <div class="scroll-shadow-btm"></div>
    </div>

    <!-- Composer -->
    <div class="composer-wrap">
      <form id="messageForm" action="{% url 'send_message' %}" method="post" enctype="multipart/form-data" class="composer">
        {% csrf_token %}
        <input type="hidden" name="receiver_id" value="{{ selected_user.id }}">
        <input type="file" id="fileInput" name="attachment" accept="image/*,.pdf,.doc,.docx,.xlsx" style="display:none">
        <button type="button" class="btn attach" id="attachBtn" title="Attach">ðŸ“Ž</button>
        <input type="text" id="messageInput" name="message" placeholder="Type a messageâ€¦">
        <button type="submit" class="btn send" id="sendButton" title="Send">âž¤</button>
      </form>
    </div>
    {% else %}
      <div class="empty"><p>Select a chat to start messaging!</p></div>
    {% endif %}
  </section>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
(function(){
  const chatBox = document.getElementById('chatMessages');
  const msgForm = document.getElementById('messageForm');
  const attachBtn = document.getElementById('attachBtn');
  const fileInput = document.getElementById('fileInput');
  const wsStatus = document.getElementById('wsStatus');
  const wsDot = document.getElementById('wsDot');
  const typingHint = document.getElementById('typingHint');
  const receiverId = msgForm ? msgForm.querySelector('[name="receiver_id"]').value : null;

  // ---------- Utilities ----------
  const qs = (sel, el=document) => el.querySelector(sel);
  const scrollToBottom = () => { if (!chatBox) return; chatBox.scrollTop = chatBox.scrollHeight; };
  const getLastRealMessageId = () => {
    const nodes = chatBox ? chatBox.querySelectorAll('.message[data-id]') : [];
    if (!nodes.length) return 0; const last = nodes[nodes.length-1]; const id = parseInt(last.dataset.id, 10); return isNaN(id)?0:id;
  };

  // ---------- Optimistic bubble ----------
  function createOptimisticBubble({ text, isFile=false, filePreviewUrl=null, filename=null }){
    const container = document.createElement('div');
    container.className = 'message sent';
    container.dataset.pending = 'true';
    container.dataset.tempid = 't_'+Date.now()+ '_' + Math.floor(Math.random()*9999);
    const p = document.createElement('p'); p.textContent = text || '' ; container.appendChild(p);
    if (isFile) {
      if (filePreviewUrl) { const img = document.createElement('img'); img.src = filePreviewUrl; img.alt='attachment'; img.style.opacity='.9'; container.appendChild(img); }
      else { const pill = document.createElement('div'); pill.className='file-pill'; pill.textContent = filename || 'Uploadingâ€¦'; container.appendChild(pill); }
    }
    const meta = document.createElement('div'); meta.className='meta'; meta.textContent = 'Sendingâ€¦'; container.appendChild(meta);
    return container;
  }
  function replaceOptimisticBubble(tempid, serverHtml){
    const tmp = qs(`[data-tempid="${tempid}"]`, chatBox);
    const frag = document.createRange().createContextualFragment(serverHtml);
    if (tmp) tmp.replaceWith(frag); else chatBox.appendChild(frag);
    scrollToBottom();
  }

  // ---------- Attachments ----------
  if (attachBtn && fileInput) {
    attachBtn.addEventListener('click', () => fileInput.click());
  }

  // ---------- Submit via Fetch (AJAX) ----------
  async function submitChatForm(formEl){
    const fd = new FormData(formEl);
    const file = fd.get('attachment');
    let previewUrl=null, filename=null;
    if (file && file instanceof File && file.size>0){ filename=file.name; if (file.type?.startsWith('image/')) previewUrl = URL.createObjectURL(file); }
    const optimistic = createOptimisticBubble({ text: fd.get('message'), isFile: !!file, filePreviewUrl: previewUrl, filename });
    chatBox.appendChild(optimistic); scrollToBottom();
    const tempid = optimistic.dataset.tempid;

    try{
      const resp = await fetch(formEl.action, { method: 'POST', body: fd, credentials:'same-origin', headers:{'X-Requested-With':'XMLHttpRequest'} });
      if(!resp.ok){ optimistic.style.opacity='.6'; optimistic.querySelector('.meta').textContent = 'Failed to send'; return; }
      const data = await resp.json();
      if (data?.ok && data.html){ replaceOptimisticBubble(tempid, data.html); if (previewUrl) URL.revokeObjectURL(previewUrl); sendAckTyping(false); }
      else { optimistic.style.opacity='.6'; optimistic.querySelector('.meta').textContent = 'Error'; }
    }catch(err){ optimistic.style.opacity='.6'; optimistic.querySelector('.meta').textContent = 'Network error'; console.error(err); }
  }

  if (msgForm){
    msgForm.addEventListener('submit', function(e){
      e.preventDefault();
      const text = qs('#messageInput', msgForm).value.trim();
      const hasFile = fileInput && fileInput.files.length>0;
      if(!text && !hasFile) return;
      submitChatForm(msgForm);
      msgForm.reset(); qs('#messageInput', msgForm).focus();
    });
  }

  // ---------- Incremental fetch ----------
  let fetching = false; let pollTimer = null; let backoffMs = 2000; // adaptive
  async function fetchNewMessages(){
    if (fetching || !chatBox) return; fetching = true;
    const lastId = getLastRealMessageId();
    try{
     {% if selected_user_id %}
           const url = `{% url 'fetch_messages' selected_user_id %}?before=${encodeURIComponent(firstId)}`;
      {% else %}
          const url = None;
      {% endif %}
      const resp = await fetch(url, { headers:{'X-Requested-With':'XMLHttpRequest'} });
      if (resp.ok){ const data = await resp.json(); if (data?.html){ chatBox.insertAdjacentHTML('beforeend', data.html); if (data.html.trim()) scrollToBottom(); } }
    }finally{ fetching = false; }
  }

  function startSmartPolling(){
    // Lightweight: only polls when tab is visible & WebSocket is down
    stopSmartPolling();
    pollTimer = setInterval(()=>{ if (document.visibilityState==='visible' && !wsConnected) fetchNewMessages(); }, backoffMs);
  }
  function stopSmartPolling(){ if (pollTimer) { clearInterval(pollTimer); pollTimer=null; } }

  // ---------- WebSocket (preferred, no refresh) ----------
  let ws=null; let wsConnected=false; let reconnectAttempts=0; let reconnectTimer=null; let manuallyClosed=false;

  function setWsStatus(ok){ wsConnected = ok; wsDot.classList.toggle('online', ok); wsStatus.textContent = ok? 'Online' : 'Reconnectingâ€¦'; }

  function wsUrl(){
    const scheme = location.protocol === 'https:' ? 'wss' : 'ws';
    return `${scheme}://${location.host}/ws/chat/{{ selected_user.id }}/`;
  }

  function connectWS(){
    if (!receiverId) return; if (ws) try{ ws.close(); }catch{ }
    setWsStatus(false);
    ws = new WebSocket(wsUrl());

    ws.addEventListener('open', ()=>{ setWsStatus(true); reconnectAttempts=0; stopSmartPolling(); });

    ws.addEventListener('message', (evt)=>{
      try{
        const payload = JSON.parse(evt.data);
        if (payload.type === 'message'){ chatBox.insertAdjacentHTML('beforeend', payload.html); scrollToBottom(); }
        if (payload.type === 'typing'){ showTypingIndicator(payload.is_typing); }
        if (payload.type === 'read'){ markMessagesRead(payload.ids||[]); }
      }catch(err){ console.warn('WS non-JSON', evt.data); }
    });

    ws.addEventListener('close', ()=>{ setWsStatus(false); if (manuallyClosed) return; scheduleReconnect(); startSmartPolling(); });
    ws.addEventListener('error', ()=>{ setWsStatus(false); try{ ws.close(); }catch{} });
  }

  function scheduleReconnect(){
    reconnectAttempts++; const delay = Math.min(15000, 1000 * Math.pow(2, reconnectAttempts));
    if (reconnectTimer) clearTimeout(reconnectTimer);
    reconnectTimer = setTimeout(connectWS, delay);
  }

  // ---------- Typing indicator ----------
  let typingTimer=null; let typingShown=false; let lastTyped=0;
  function showTypingIndicator(show){
    if (show && !typingShown){ typingHint.innerHTML = '<span class="dots" aria-hidden="true"></span> typingâ€¦'; typingShown=true; }
    if (!show && typingShown){ typingHint.textContent=''; typingShown=false; }
  }
  function sendTyping(isTyping){
    if (wsConnected){ ws.send(JSON.stringify({ type:'typing', is_typing:isTyping })); }
  }
  function sendAckTyping(active){ // used after send
    sendTyping(false);
  }
  const messageInput = document.getElementById('messageInput');
  if (messageInput){
    messageInput.addEventListener('input', ()=>{
      const now = Date.now(); if (now - lastTyped > 250){ sendTyping(true); lastTyped = now; }
      if (typingTimer) clearTimeout(typingTimer);
      typingTimer = setTimeout(()=> sendTyping(false), 1200);
    });
  }

  // ---------- Read receipts (simplified) ----------
  function markVisibleAsRead(){
    // send last visible id to server
    const lastId = getLastRealMessageId();
    navigator.sendBeacon?.('{% url 'mark_read' %}', new URLSearchParams({ chat_with: '{{ selected_user.id }}', last_id: lastId }));
  }
  chatBox?.addEventListener('scroll', ()=>{ if (chatBox.scrollTop + chatBox.clientHeight >= chatBox.scrollHeight - 60) markVisibleAsRead(); });

  function markMessagesRead(ids){
    ids.forEach(id => {
      const el = qs(`.message[data-id="${id}"]`); if (!el) return; const meta = el.querySelector('.meta'); if (meta) meta.textContent = 'Seen';
    });
  }

  // ---------- Infinite older messages on scroll-up ----------
let loadingOlder = false;
const olderSentinel = document.getElementById('olderSentinel');

async function loadOlder() {
    if (loadingOlder) return;
    loadingOlder = true;
    olderSentinel.style.display = 'block';

    // find first message id
    const first = chatBox.querySelector('.message[data-id]');
    const firstId = first ? parseInt(first.dataset.id, 10) : 0;

    // only build URL if a chat is open
    {% if selected_user_id %}
    {% else %}
    {% endif %}
    const path = window.location.pathname;
    
    // Check for /chat/ followed by any number
    {% if selected_user_id %}
           const url = `{% url 'fetch_messages' selected_user_id %}?before=${encodeURIComponent(firstId)}`;
      {% else %}
          const url = None;
      {% endif %}
    try {
        if (url) {
            const resp = await fetch(url, {
                headers: { 'X-Requested-With': 'XMLHttpRequest' }
            });
            
            if (resp.ok) {
                const data = await resp.json();
                if (data?.html) {
                    const prevHeight = chatBox.scrollHeight;
                    chatBox.insertAdjacentHTML('afterbegin', data.html);
                    chatBox.scrollTop = chatBox.scrollHeight - prevHeight;
                }
            }
        }
    } finally {
        loadingOlder = false;
        olderSentinel.style.display = 'none';
    }
}

chatBox?.addEventListener('scroll', () => {
    if (chatBox.scrollTop < 60) loadOlder();
});
  // ---------- Init ----------
  if (receiverId){
    connectWS();
    document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState==='visible' && !wsConnected) fetchNewMessages(); });
    // Initial bottom scroll
    setTimeout(scrollToBottom, 50);
  }

  // Clean up on page unload
  window.addEventListener('beforeunload', ()=>{ manuallyClosed=true; try{ ws?.close(); }catch{} });
})();
</script>
{% endblock %}